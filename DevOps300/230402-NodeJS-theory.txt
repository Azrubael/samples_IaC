***
Большое O *** это нотация, используемая для описания вычислительной сложности алгоритма.
Данная форма записи используется для выражения доминантного члена функций стоимости алгоритмов в худшем случае.
Она указывает на характер верхней границы ассимптотической кривой сложности. В компьютерных науках выделяют и другие нотации: Омега (нижняя граница) и Фи (одновременно нижнее и верхнее ограничение).
	+++
Как правило, бизнес-логика больше фокусируется на лучшей временной сложности, а постранственая сложность оценивается во вторую очередь.
Для O(n^2) увеличение n в 10 раз дает прирост в 100 раз.
Для O(nlog(n)) увеличение n в 10 раз дает прирост в 34 раза.
Для О(1) увеличение объема входных данных не имеет значения.
Экспотенциальный алгоритм О(2^n) - очень ограниченно применим.
Факториальный алгорим O(n!) - практически бесполезный. Используется для недетерминированных полиномиальных (NP-полных) задач.


***
Императивное программирование *** это парадигма (можно сказать методология) программирования, для которой характерно следующее:
=== в исходном коде программы записываются инструкции;
=== инструкции должны выполняться последовательно;
=== данные, получаемые при выполнении предыдущих инструкций, могут читаться из памяти последующими инструкциями;
=== данные, полученные при выполнении инструкции, могут записываться в память.
Императивная программа похожа на приказы, то есть представляет собой последовательность команд, которые должен выполнить процессор, и описывает процесс вычислений, как последовательное изменение состояний.


***
Итеративная стратегия состоит в использовании циклов (например, for и while) для повторения процесса до тех пор, пока не окажется соблюдено некое условие. Каждый шаг в цикле называется итерацией.
Итеративный программный код обычно выполняется быстрее рекурсивного, но вместе с тем он более громоздкий и его труднее понять.


***
Класс ООП *** модель для создания информационных объектов определённого типа и описывающая:
== их структуру, то есть набор полей и их начальное состояние;
== определяющая алгоритмы для работы с этими объектами, то есть функции или методы.


***
Микросервисная архитектура *** вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей-микросервисов, взаимодействующих с использованием экономичных сетевых коммуникационных протоколов (в стиле REST с использованием, например, JSON, Protocol Buffers, Thrift).


***
ООП - методология программирования, основанная на концепции «объектов», которые могут содержать данные и код. При этом в «объектах« данные представлены в виде полей (часто называемых атрибутами или свойствами), а код — в форме процедур (часто называемых методами). Многие из наиболее широко используемых языков программирования (C++, Java, Python и т. д.) являются мультипарадигмальными и в большей или меньшей степени поддерживают ООП, обычно в сочетании с императивным и процедурным программированием.
== В ГУГЛ ООП - гибкая, мощная парадигма, в которой классы представляют и определяют концепции, а объекты являются экземплярами классов. Классы имеют связанные с ними атрибуты и методы. Атрибуты — это характеристики класса, а методы — это функции, являющиеся частью класса. В объектно-ориентированном программировании концепции моделируются как классы и объекты. Идея определяется с помощью класса, и экземпляр этого класса называется объектом.
Методы - это функции, которые оперируют атрибутами экземпляров класса.


***
Паттерны ООП *** повторяемые архитектурные конструкции, представляющие собой решения проблем проектирования в рамках некоторого часто возникающего контекста.
Паттерны ООП показывают отношения и взаимодействия между классами и объектами, без определения того, какие конечные классы или объекты приложения будут использоваться.
Различают паттерны: порождающие, структурные и поведенческие.
**Порождающие паттерны**
  == Прототип - Определяет интерфейс создания объекта через клонирование другого объекта вместо создания через конструктор.
  == Строитель - Класс, который представляет собой интерфейс для создания сложного объекта. 
  == Фабрика - Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанциировать. 
  == Абстрактная фабрика - Класс, который представляет собой интерфейс для создания компонентов сисемы. 
**Структурные паттерны**
  == Адаптер - Объект, обеспечивающий взаимодействие двух других объектов, один из которых использует, а другой предоставляет несовместимый с первым интерфейс. 
  == Мост - Структура, позволяющая изменять интерфейс обращения и интерфейс реализации класса независимо.
  == Декроратор - Класс, расширяющий функциональность другого класса без использования наследования. 
**Поведенческие паттерны**
   == Стратегия - Предназначен для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости.
   == Наблюдатель - Определяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии. 
   == Посредник - Обеспечивает взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга. 
   == Хранитель - Позволяет не нарушая инкапсуляции зафиксировать и сохранить внутренние состояния объекта так, чтобы позднее восстановить его в этих состояниях. 


***
Принципы ООП: инкапсуляция, полиморфизм, наследование.
   *** Инкапсуляция обеспечивает сокрытие, но им не является, это:
 а) == объединение данных и функций, которые ими управляют, в единый компонент;
 б) == это механизм языка, который ограничивает доступ одних элементов программы к другим.
   === Наследование - механизм языка, позволяющий описывать новый класс объектов на основе существующего описания классов.
Формирование иерархии родственных объектов за счет наследования нужно для обеспечивания полиморфизма. Без полиморфизма наследование вредно, т.к. усиливает связывание элементов программы.
Наследование бывает желаемое и действительное.
  === Полиморфизм - главная особенность действительного ООП и второстепенная особенность желаемого ООП:
a) == специальный (ad hoc), перегрузка методов с разными типами принимаемых аргументов. При динамической типизации в языке полиморфизм 'ad hoc' - совершенно естественное явление;
b) == параметрический (дженериками);
c) == полиморфизм наследования [подтипов] (именно он является частью действительного ООП). Он реализуется в процессе использования интерфейсов и паттернов ООП (например в паттерне "стратегия").


***
Рекурсия
Мы говорим о рекурсии, когда функция делегирует работу своим клонам.
Рекурсивные алгоритмы обычно проще и короче итеративных.
Рекурсивные алгоритмы имеют базовые случаи, когда объем входных данных слишком мал, чтобы его можно было продолжать сокращать. Базовые случаи для функции fib — числа 1 и 2.
function fib(n)
	if n ≤ 2
		return 1
	return fib(n-1) + fib(n-2)


***
Функциональное программирование *** парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании. Предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы.
Лямбда-исчисление является основой для функционального программирования. Предполагает создание анонимных колбэк функций, которые можно определить прямо в том месте, где они используются, и которые имеют доступ к локальным переменным текущей функции (это называется замыкание).
Процесс превращения функций многих переменных в функцию одной переменной называется каррирование.


***
API *** это набор условных соглашений, которые позволяют разным програмам общаться и взаимодействовать друг с другом.
Приложение, отправляющее запрос, называется клиентом, а приложение, отправляющее ответ, называется сервером. API обеспечивает взаимодействие между сервисами посредством циклов “запрос-ответ”. 
В начале 2000-х годов существовало только два реальных протокола API, о которых должны были знать большинство разработчиков: SOAP и REST. Однако в последние годы появилось много новых протоколов, такие как новые реализации RPC, GraphQL, Thrift и прочие.


***
CI/CD *** Continous Integration & Continous Delivery - Непрерывная интеграция + Непрерывная доставка. Это метод частой доставки приложений клиентам путем внедрения автоматизации на этапах разработки приложений. Обеспечивает постоянную автоматизацию и непрерывный мониторинг на протяжении всего жизненного цикла приложений, от этапов интеграции и тестирования до поставки и развертывания.


***
CRM *** Customer Relationship Management - это управление взаимоотношениями с клиентами и относится ко всем стратегиям, методам, инструментам и технологиям, которые использует бизнес для развития, удержания и привлечения клиентов. Это особый подход к ведению бизнеса, при котором во главу угла деятельности компании ставится клиент.
Основная цель внедрения CRM - создание единой экосистемы по привлечению новых и развитию существующих клиентов. 


***
CRUD *** copy, read, update, delete


***
CQRS *** Command Query Responsibility Segregation - разделение обязанностей команд и запросов в системе. Это означает разделение логики приложения по вертикали. В дополнение к этому отделяется изменение состояния (обработка команд) от извлечения данных (обработка запросов).


***
CQS ***  Command Query Separation — это концепция проектирования программного обеспечения, определяющая два типа операций, обрабатываемых в системе: команда выполнения задачи и запрос, возвращающий информацию. В соовтетстви с этим принципом не должно быть одной функции, выполняющей обе эти задачи.


***
Dependency Injection [DI] *** внедрение зависимостей, процесс предоставления внешней зависимости программному компоненту. Это делается для отделения программного компонента с целью тестирования или замены по необходимости альтернативными элементами.


***
Dependency Inversion Principle *** принцип инверсии зависимостей. Принцип, при котором модули верхних уровней не должны импортировать сущности из модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей, но детали должы зависеть от абстракций.


***
DDD *** Domain Driven Desighn - подход к разработке программного обеспечения, сосредативающий внимание на моделировании, чтобы оно соответствовало предметной области в соответствии с мнением экспертов в этой области. Описывает независимые предметные области, как ограниченные контексты и выделяет общий язык для обсуждения этих проблем. Каждый ограниченный контекст соотносится с микросервисом.
Преследует следующие цели:
== размещение основного внимания проекта на основном домене и логике домена;
== создание сложных проектов на основе модели предметной области;
== творческое сотрудничество между техническими экспертами и экспертами в предметной области для итеративного уточнения концептуальной модели, которая решает конкретные проблемы предметной области.


***
Docker *** это это операционная система для контейнеров и программная платформа для быстрой разработки, тестирования и развертывания приложений.
Использование Docker позволяет быстрее и эффективнее доставлять или перемещать код, стандартизирует выполняемые приложениями операции и в целом экономит средства, оптимизируя использование ресурсов.


***
DOM *** объектная модель документа - объектно-ориентированная модель HTML страницы. Для управления DOM может использоваться JavaScript, который имеет мощные инструменты для гибкого динамического изменения содержания DOM.
Существует два способа обработки событий в объектной модели HTML: всплытие и перехват. При всплытии событие, лежащее глубже всех по дереву DOM, обрабатывается в первую очередь, а затем - остальные по очереди всплытия.
При перехвате первым обрабатывается внешнее событие, а затем обработка распространяется вглубь DOM.


***
DRY *** Don't Repeat Yourself


***
DSA *** data structures and algorithmes


***
DBMS *** Database Management System - сокращенно СУБД. Структура СУБД:
a) == ядро, отвечает за управление данными и журнализацию;
б) == процессор языка базы данных;
в) == подсистема поддержки времени исполнения, которая интерпретирует программы манипуляции данными, создающие пользовательский интерфейс с СУБД;
г) == сервисные программы (внешние утилиты), обеспечивающие дополнительные возможности.
RDBMS, или Relational Database Management System == это Postgres, MySQL, MariaDB, SQLite и MSSQL.


***
Event Loop *** Цикл событий, который позволяет Node.js выполнять неблокирующие операции ввода/вывода (несмотря на то, что JavaScript является однопоточным) путем выгрузки операций в ядро системы, когда это возможно. Диаграмма ниже показывает порядок выполнения операций в цикле событий.
   ┌───────────────────────┐
┌─>│       таймеры         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O коллбэки      │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │ ожидание, подготовка  │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │  входящие:    │
│  │        опрос          │<─────┤  соединения,  │
│  └──────────┬────────────┘      │  данные, итд. │
│  ┌──────────┴────────────┐      └───────────────┘
│  │      проверка         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    коллбэки `close`   │
   └───────────────────────┘


***
Event Sourcing *** это шаблон для хранения данных в виде событий в журнале только для добавления. Это предполагает и сохранение событий и сопутствующего контекста. При этом вы знаете, что счет-фактура был отправлен и по какой причине из той же части информации. В других шаблонах хранения контекст бизнес-операции обычно теряется или иногда сохраняется в другом месте.


***
Grasp *** general responsibility assignment software patterns - шаблоны, используемые в объектно-ориентированном проектировании для решения общих задач по назначению ответственностей классам и объектам. Подробнее - см. паттерны ООП.


***
Inversion of Control *** Методика работы с потоком управления, когда (например) выполнение инструкций контролируется третьей стороной.
[Принцип, при котором каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.]


***
JavaScript *** мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией спецификации ECMAScript (стандарт ECMA-262).
Название JavaScript является зарегистрированным товарным знаком корпорации Oracle в США.


***
JSON *** JavaScriot Object Notation. Популярный формат обмена данными, в том числе используется для сообщений НТТР протокола, указаний по развертыванию нагрузки кубернетес и даже для сохранения в ориентированных для этого СУБД. Фактически он является стандартным форматом передачи данных для API (в т.ч. для сериализации и десиаризации передаваемого байт-кода методами parse/stringify).
Это наборы пар данных в виде текстового ключа и соответствующих ему объектов (в т.ч. массивов и других JSON документов). Разработан Дугласом Крокфордом.


***
GraphQL *** это язык запросов, используемый клиентскими приложениями для работы с данными. GraphQL для передачи данных клиенту и получения их от него полагается на простые GET или POST-запросы: R (reading, чтение). Изменение данных в GraphQL называют мутациями (mutation), они относятся к буквам C, U и D акронима CRUD. Все запросы GraphQL начинаются с «корневого запроса», а то, что нужно получить в ходе выполнения запроса, называется полем.


***
HTTP (ЭйчТиТиПи) *** Протокол передачи гипертекста. Имеет прикладной уровень и лежит в основе обмена данными в Интернете, где гипертекстовые документы содержат гиперссылки на другие ресурсы, к которым пользователь может легко получить доступ, например, щелкнув мышью или коснувшись экрана в веб-браузере.
HTTP был разработан ещё в начале 1990-х годов, за счёт своей расширяемости в дальнейшем он все время совершенствовался. Чаще всего использует возможности другого протокола - TCP (или TLS - защищённый TCP) - для пересылки своих сообщений, однако любой другой надёжный транспортный протокол тоже теоретически может быть использован для доставки таких сообщений.
HTTP — это клиент-серверный протокол. Каждый запрос (англ. request) отправляется серверу, который обрабатывает его и возвращает ответ (англ. response). Между этими запросами и ответами как правило существуют многочисленные посредники, называемые прокси, которые выполняют различные операции и работают как шлюзы или кэш.
HTTP не имеет состояния, но имеет сессию. Куки позволяют использовать сессии с сохранением состояния.


***
KISS *** Keep it stupid simple - Оставь это до тупого простым


***
Kubernetes *** это портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами, которая облегчает как декларативную настройку, так и автоматизацию.
Использование контейнеров и Кубернетес - отличный способ связать и запустить приложения. Если контейнер выходит из строя, необходимо запустить другой контейнер.
Кубернетес предоставляет:
== Мониторинг сервисов и распределение нагрузки.
== Оркестрацию хранилища.
== Автоматическое развертывание и откаты программного обеспечения.
== Перезапуск и замену отказавших контейнеров, которые не проходят определенную пользователем проверку работоспособности.
== Управление конфиденциальной информацией и конфигурацией.


***
Middleware *** Функции промежуточного программного обеспечения - выполняются в последовательности, определенной в коде, и обычно могут:
  == запускать код при каждом запросе;
  == манипулировать или изменять объекты запроса и ответа;
  == прекратить ответ — возможно, если пользователь не вошел в систему;
  == вызвать следующую промежуточную функцию.
Обычно они принимают три аргумента: объекты запроса, ответа и колбэк следующей middleware функции.


***
Применение паттернов MVC, MVP, MVVM ***
++ ЭмВиСи - Используется в ситуации, когда программное связывание (биндинг) представления и другими частями приложения невозможна (не получается использовать MVVM или MVP).
++ ЭмВиПи - Используется  в ситуации, когда невозможно связывание данных (биндинг).
++ ЭмВиВиЭм - Используется в ситуации, когда возможно связывание данных без необходимости ввода специальных интерфейсов представления (т.е. отсутствует необходимость реализовывать IView);


***
Model-view-adapter, MVA *** Размещет модель, адаптер или промежуточный контроллер и представление линейно, без каких-либо прямых связей между моделью и представлением. Тогда как традиционный MVC упорядочивает модель (то есть структуры данных и хранилище), представление (то есть пользовательский интерфейс) и контроллер (то есть бизнес-логику) в виде треугольника с моделью, представлением и контроллером в качестве вершин.


***
Model-View-Controller, MVC, Модель-Вид-Контроллер *** Это архитектурный шаблон программного обеспечения, обычно используемый для разработки пользовательских интерфейсов, который делит связанную программную логику на три взаимосвязанных компонента: модель, представление и контроллер - таким образом, что модификация каждого компонента может осуществляться независимо.
== Модель предоставляет данные и реагирует на команды контроллера, изменяя своё состояние. обычно это таблица в базе данных приложения.
== Представление отвечает за отображение данных модели пользователю, реагируя на изменения модели. Это любое представление информации, такое как диаграмма, гистограмма или таблица. Возможно несколько представлений одной и той же информации (гистограмма для руководства и табличное представление для бухгалтеров).
== Контроллер интерпретирует действия пользователя, оповещая модель о необходимости изменений. Принимает ввод и преобразует его в команды для модели или представления. Обычно у каждого типа модели есть связанный с ним контроллер; например, если приложение меет модель клиента, оно, как правило, также имеет связанный с ним контроллер клиентов. Тем не менее, разработчики могут создавать другие виды контроллеров, если захотят.


***
Model-View-Presenter, MVP *** Это шаблон проектирования пользовательского интерфейса, который  разработан для облегчения автоматического модульного тестирования и улучшения разделения ответственности в презентационной логике (для отделения логики от отображения). Элемент Представитель в данном шаблоне берёт на себя функциональность посредника (аналогично контроллеру в MVC) и отвечает за управление событиями пользовательского интерфейса (например, использование мыши) так же, как в других шаблонах обычно за это отвечает представление.
== Модель - данные для отображения.
== Вид - реализация данных отображения. Обычно экземпляр Вида создаёт экземпляр Представителя, передавая ему ссылку на себя. При этом Представитель работает с Видом в абстрактном виде, через его интерфейс.
== Представитель - реализует взаимодействие между Моделью и Видом и содержит в себе всю логику представления данных о предметной области. Представитель при необходимости получает данные из хранилища и преобразует для отображения в Вид.


***
Model–view–viewmodel, MVVM, эмвивиэм *** Используется практически только в графических интерфейсах для разделения модели и её представления при одновременном программном свяывании свойств для отображения.
== Модель предстваляет собой логику работы с данными и описание фундаментальных данных, необходимых для работы приложения.
== Представление это графический интерфейс (окна, списки, кнопки и т п.), который выступает подписчиком на события изменений значений свойств или команд, предоставляемых Моделью Представления.
== Модель Представления это с одной стороны абстракция Представления, а с другой - обёртка данных из Модели, подлежащиx связыванию. То есть, она содержит Модель, преобразованную к Представлению, а также команды, которыми может пользоваться Представление, чтобы влиять на Модель.
== Привязка - Модель Представления напрямую привязывается с одной стороны к свойствам Модели, а с другой - к Представлению. Это используется для синхронной отправки и получения обновлений. Для эффективного функционирования требуется технология привязки или генерация стандартного кода для привязки.


***
Model-View-Presenter-ViewModel, MVP-VM, эмвипи-виэм *** Это модификация ЭмВиПи, которую можно реализовать по-разному. Основная цель состоит в том, чтобы разделить функциональные возможности, чтобы легче проводить модульное тестирование и улучшать поддержание кода в долгосрочной перспективе. Presenter будет выступать в качестве моста между View, ViewModel и Model. При этом ViewModel будет иметь только те свойства, которые используются для привязки данных к представлению и хранения данных, поступающих из представления.


***
NODE.js *** среда выполнения, которая в т.ч. интерпретирует (преобразует) код JavaScript в машинный код при помощи движка Google V8 (C++). Этот движок сам занимается выделением памяти для объектов, а также сборкой мусора. Другой частью NODE.js является тоже написаный на С++ кроссплатформенный библиотечный модуль LIBUV, который отвечает за ввод-вывод и реализацию Event Loop.
++DENO.js++ как и Ноде представляет собой оболочку вокруг движка JavaScript Google V8. Deno прежде всего включает компилятор TypeScript в свой исполняемый образ. Deno решает три основных проблемы Node.js. Вот эти проблемы:
== плохо спроектированная модульная система, основанная на централизованном распределении;
== множество устаревших API, которые необходимо поддерживать;
== отсутствие безопасности.
Deno по умолчанию не позволяет программе обращаться к диску, сети, подпроцессам или переменным окружения. Когда вам нужно разрешить что-либо из этого, вы можете включить флаг командной строки, который может быть настолько детальным, насколько вам нравится. Кроме того Node позволяет продолжить выполнение программы после неотловленной ошибки, что дает непредсказуемые результаты.


***
NODE.js *** преимущества
== скорость работы приложений, построенных на NODE.js превышает скорости Python и PHP в т.ч. за счет неблокирующего ввода/вывода;
== ресурсов и энергии для работы сервера в общем случае требуется меньше, чем для конкурирующих платформ;
== очень богатый менеджер пакетов NPM, где тысячи библиотек и прототипов готовых приложений;
== фронт и бэк - с применением одного движка. Единая кодовая база с JavaScript означает, что разработка и поддержание серверного приложения может быть выгоднее альтернативных вариантов.


***
Promise *** Промис - Объект в JavaScript, который выступает в качестве заполнителя для асинхронной задачи, которая еще не завершена. Это объект, который возвращается асинхронным методом. Вместо немедленного возврата значения этот объект возвращяет "обещание".
Состояния промиса - pending, resolved, rejected (ожидает, решен, отклонен).
Промисы используются для запросовй ЭйПиАй (API requests) и для операций ввода-вывода (I/O) и других операций, которые требуют ресурсов и блокируют поток.


***
PYTHON 3 data structures ***
== List (список - одномерный массив)
== String (список букв - одномерный массив, иммутабелен)
== Tuple (кортеж - иммутабелен)
== Dictionary (словарь, аналог объекта JavaScript)
	В словаре ключом может быть string, integer, float, tuple.
	Ключи словарей должны быть иммутабельных типов:
Numbers, Booleans, Strings, Tuples, and other immutable types.
== Set (набор - иммутабельный словарь, не упорядочен и не индексирован)
	SETs are used when you want to store a collection of unique items.


***
REACT.js ***
Популярные вопросы:
1) == Зачем нужен REACT.js (в чем его преимущество) ==
Это JavaScript-библиотека для создания пользовательских интерфейсов. Она позволяет собирать сложный пользовательский интерфейс из маленьких изолированных кусочков кода, называемых «компонентами».
Операции над Дом-деревом очень ресурсоемкие. Реакт оптимизирует обработку ДОМ-дерева за счет изменения только тех элементов, которые нужно. Изменение ДОМ-дерева происходит при помощи весьма сложных оптимизированных алгоритмов согласования фактического ДОМ и его виртуального представления Реакт. Алгоритмы Реакт сами устанавливают приоритетность.
2) == Что такое компоненты реакт ==
Маленькие изолированные фрагменты кода, отвечающие за отрисовку элементов пользовательского интерфейса. Реакт имеет несколько видов компонентов: классовые, функциональные (Какие еще). Компоненты принимают параметры, которые называются пропсами и возвращают из метода render() иерархию представлений для отображения. Если точнее, render() возвращает React-элемент, который является легковесным описанием того, что нужно отрендерить.
Всегда будет корневой компонент, который монтируется в тело 'index.html' файла общей разметки для одностраничного приложения. 
3) == Как передаются свойства между компонентами?
	а) ++ через пропсы, от родителей к наследникам (это проще всего);
	б) ++ когда компоненты далеко друг от друга, то через пропсы и через все компоненты, которыми они связаны (компонент - через компонент - через компонент). Это простой вариант для передачи данных между компонентами;
	в) ++ через рефс (прямая ссылка на соответствующую структуру данных). Требуется создать рефс, который будет виден во всех компонентах и потом передавать ссылку на созданный рефс;
	г) ++ через менеджеры стейта типа REDUX. При этом все компоненты должны быть подписаны на его структуру данных;
	д) ++ с версии 19 в REACT.js появился REACT Сontext (сильно упрощенный стейт менеджер "из коробки реакт 19").
4) == Стадии жизненного цикла компонентов (монтирование-обновление-размонтирование). Методы работы с компонетами
	а) ++ с классовыми компонентами
	(три основных и три вспомогательных didMount, didUpdate willUnmount) в новый проектах практически не используются;
	б) ++ с функциональными компонентами
	( ** хуки типа useEffect, useState, useContext - покрывают 90% случаев ** ).
В новом реакт 19 появились хуки, и useEffect может заменить применение для нескольких стадий. Вторым параметром он принимает массив изменяемых переменных, которые управляют вызовом этого хука (один раз, каждый раз и проч.).


***
ReactDOM *** Отвечает за отрисовку компонентов в браузере. Это пакет, который предоставляет специфичные для DOM методы, которые можно использовать на верхнем уровне веб-приложения и в качестве инструмента, дающего выход за пределы модели React, если это нужно.


***
React хуки: ***
useState(), useEffect(), useRef(), useMemo(), useCallback(), useContext()
Это некоторые функции, которые предоставляет Реакт. Они начинаются со слова  'use...'. Реакт хуки можно использовать либо в функциональных компонентах, либо в своих хуках. При этом хуки могут быть использованы только на верхнем уровне вложенности.
Хук useRef - механизм в React, позволяющий брать ДОМ-элементы или другие переменные в React и изменять их в императивном стиле.


***
Regexp *** Regular Expression - По сути, поисковый запрос для текста, который выражается с помощью строкового шаблона. Регулярные выражения позволяют ответить на вопросы типа:
== каковы все четырехбуквенные словам в файле?
== сколько различных типов ошибок в этом журнале ошибок?


***
REST API *** популярный архитектурный подход для построения бэкенда веб-приложения. Это своего рода надстройка над НТТР.
Representational State Transfer (REST) — это программная архитектура, которая определяет условия работы API. 


***
REST *** стиль архитектуры программного обеспечения для построения распределенных масштабируемых веб-сервисов. REST - сервисы позволяют оптимальным образом производить обработку НТТР-протокола и всегда подразумевают клиент-серверное взаимодействие.
RESTful API обладает следующими преимуществами:
== Возможность масштабирования
== Гибкость
== Независимость
Внутри GraphQL встроено множество элементов из модели REST


***
REPL *** цикл чтение-вычисление-вывод (read-evaluate-print loop)


***
Software as a Service *** SaaS *** is when a Cloud provider delivers an entire application or program to the customer.
Platform as a Service *** PaaS *** is when a Cloud provider offers a preconfigured platform to the customer.
Infrastructure as a Service *** IaaS *** is when a Cloud provider supplies only the bare-bones computing experience. Generally, this means a virtual machine environment and if you need a high level of control over the software you're running and how it interacts with other pieces in your system, you might want to choose Infrastructure as a Service.


*** 
SCRUM *** легкий фреймворк, который помогает создавать ценность с помощью адаптивных решений комплексных проблем. Может использоваться не только в сфере разработки ПО но и в других производственных отраслях.
Название СКРАМ пришло из регби.
Это также минимально необходимый набор мероприятий, артефактов, ролей, на которых строится процесс СКРАМ-разработки, позволяющий за фиксированные небольшие промежутки времени, называемые спринтами, предоставлять конечному пользователю работающий продукт с новыми бизнес-возможностями, для которых определён наибольший приоритет.
В конце спринта СКРАМ-команда встречается на обзорном совещании результатов спринта.
Строго фиксированная небольшая длительность спринта (от 1 до 4 недель) снижает риски, и даёт возможность быстро получить обратную связь от заказчика, чтобы скорректировать видение продукта. 


***
Sequelize это ORM *** Object-Relational Mapping - объектно-реляционное отображение для работы с реляционными системами управления базами данных. Это далеко не единственная ORM для работы с названными базами данных, но одна из самых продвинутых и проверенных временем.
ОЭРЭМ хороши тем, что позволяют взаимодействовать с базами данных на языке приложения (JavaScript), то есть без использования специально предназначенных для этого языков (типа SQL).
Думайте об ОЭРЭМ как об абстрактной структуре базы данных. Преимущества включают в себя:
	++ Обычно легче освоить, чем определенные диалекты SQL или NoSQL.
	++ Время разработки сокращается, поскольку хороший ОЭРЭМ обеспечивает безопасность и целостность данных.
	++ Можно создавать модели данных в коде приложения. Нет необходимости напрямую создавать или изменять таблицы.
	++ ОЭРЭМ отслеживают изменения и при необходимости могут переносить схемы.
	++ ОЭРЭМ поддерживают несколько баз данных, что может быть важно, если вы распространяете веб-программное обеспечение для установки другими пользователями.
** Недостатки ORM:
	== Иногда их может быть трудно освоить.
    == Управление Sequelize пугает, и эти знания не будут применимы где-либо еще.
	== ОЭРЭМ не спасет вас от неверных решений в отношении данных.
	== Более сложные запросы могут быть трудны для выражения.
	== ОЭРЭМ медленнее, и запросы не обязательно будут оптимизированы.
	== Вы не сможете использовать дополнительные параметры, предоставляемые в конкретной базе данных.
	== Ошибки, связанные с базой данных, может быть труднее отлаживать.
ОЭРЭМ идеально подходит для прототипов и небольших проектов. Собственные драйверы с оптимизированными запросами, созданными вручную, лучше подходят для крупных проектов, где требования к данным являются более важными.


***
SDK *** ЭсДиКей - software developer kit - набор инструментов разработчика


***
SOLID *** пособствует созданию такой системы, которую будет легко поддерживать и расширять в течение долгого времени.
   == Single responsibility principle == Принцип единственной ответственности.
	Каждый класс/модуль должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в него.
   == Open-closed principle == Принцип открытости/закрытости
	Программные сущности (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменения.
   == Liskov substitution principle == Принцип подстановки Лисков
	Функции/классы, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
   == Interface segregation principle = Принцип разделения интерфейса
	Много интерфейсов специального назначения лучше, чем один интерфейс общего назначения.
   == Dependency inversion principle - Принцип инверсии зависимостей
	Зависимость на Абстракциях, а не на чем-то конкретном.


*** TypeScript *** это среда выполнения JavaScript с проверкой типов во время компиляции.


***
Yagni *** You aren't gonna need it - Вам это не понадобится - отказ добавления функциональности, в которой нет непосредственной надобности.



